<!doctype html>
<!--
  Template: templates/pages/pdf_toolbox.html
  Purpose: Smart PDF Toolbox page ‚Äî upload PDFs, preview thumbnails, select pages,
           and perform actions like split, merge, compress, rotate, and export.

  Notes for maintainers:
  - This file is a Jinja template and uses `url_for` to build route URLs. Keep
    those constructs intact (e.g. {{ url_for('pdf.smart_upload') }}).
  - The header/navigation and footer were aligned with `templates/index.html`
    to provide consistent site navigation and accessibility features.
  - This refactor replaces Bootstrap with Tailwind utility classes and adds a
    small mascot + confetti surprise when generation succeeds.
-->
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Smart PDF Toolbox</title>
  <!-- Use Tailwind CDN (lightweight quick-edit) to restyle the page. For
       production consider building Tailwind locally and purging unused styles. -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />

  <style>
    /* kept small helper styles for thumbnails and sticky actions */
    body {
      padding-bottom: 180px;
    }

    .thumb-wrapper {
      display: inline-block;
      margin: 6px;
      border-radius: 6px;
      overflow: hidden;
    }

    #pagesList {
      max-height: 360px;
      overflow: auto;
    }

    #thumbs {
      max-height: 360px;
      overflow: auto;
      white-space: normal;
    }

    .angle-display {
      margin-left: 8px;
      font-weight: 600;
      color: #111827;
    }

    /* mascot animation */
    @keyframes wave {
      0% {
        transform: translateY(0) rotate(0deg);
      }

      25% {
        transform: translateY(-3px) rotate(-3deg);
      }

      50% {
        transform: translateY(0) rotate(0deg);
      }

      75% {
        transform: translateY(-2px) rotate(2deg);
      }

      100% {
        transform: translateY(0) rotate(0deg);
      }
    }

    /* confetti canvas sits above content during celebrations */
    #confetti-canvas {
      position: fixed;
      pointer-events: none;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: 9999;
    }
  </style>
</head>

<body class="min-h-screen bg-gradient-to-br from-red-50 via-white to-red-100 text-gray-800">
  <a class="sr-only focus:not-sr-only p-4 bg-white text-blue-700 rounded-md absolute" href="#main-content">Skip to
    content</a>

  <!-- Header / Navigation: site branding and top-level links -->
  <nav role="navigation" aria-label="Main navigation"
    class="container mx-auto px-4 py-3 flex items-center justify-between">
    <div class="flex items-center space-x-3">
      <a href="{{ url_for('main.index') }}" class="flex items-center space-x-3" aria-label="RX Smart Tools home">
        <div class="p-2 rounded-lg bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-md">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"
            role="img" aria-hidden="false">
            <title>RX Smart Tools logo</title>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6l4 2" />
          </svg>
        </div>
        <span class="text-xl font-bold">RX Smart Tools</span>
      </a>
      </a>
    </div>

    <div class="hidden md:flex items-center space-x-3 text-sm">
      <a href="{{ url_for('pdf.smart_index') }}" class="px-2 py-1 rounded-md hover:bg-gray-100">PDF Toolbox</a>
      <a href="{{ url_for('excel.excel_tool') }}" class="px-2 py-1 rounded-md hover:bg-gray-100">Excel Toolbox</a>
      <a href="{{ url_for('files.saved_files') }}" class="px-2 py-1 rounded-md hover:bg-gray-100">Saved Files</a>
    </div>
  </nav>

  <!-- Main content: PDF toolbox workspace -->
  <main id="main-content" class="container mx-auto px-4 mt-6">
    <div class="bg-white/70 backdrop-blur-md rounded-xl p-6 shadow-sm">

      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-4 w-full">
          <div
            class="w-12 h-12 flex items-center justify-center bg-white rounded-lg shadow-sm border border-red-100 flex-shrink-0">
            <svg viewBox="0 0 64 64" class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img"
              focusable="false">
              <rect x="8" y="6" width="48" height="52" rx="6" fill="#ef4444" />
              <text x="20" y="36" fill="#fff" font-size="10" font-weight="700">PDF</text>
            </svg>
          </div>

          <div class="flex-1 min-w-0">
            <h1 class="text-2xl sm:text-3xl font-extrabold leading-tight">
              Smart PDF Toolbox
            </h1>
            <p class="mt-1 text-gray-600">Upload PDFs, preview thumbnails, select pages, then split/merge/rotate or
              export.</p>
          </div>

          <div class="w-1/3 min-w-[220px]">
            <label for="pdfUpload" class="block text-sm font-medium text-gray-700 sr-only">Upload PDF</label>

            <!-- upload area: simplified, no filename overlay here.
             Progress/queue shown inside the drop area instead ‚Äî uploaded filenames
             remain in the Uploaded Files explorer. -->
            <div id="uploadDrop"
              class="relative mt-3 flex flex-col items-center justify-center p-4 border-2 border-dashed rounded-xl cursor-pointer bg-gradient-to-br from-red-50 to-white hover:from-red-100 text-center w-full h-36 transition"
              role="button" tabindex="0" aria-label="Upload PDF, click or drag and drop"
              onclick="document.getElementById('pdfUpload').click()"
              onkeydown="if(event.key==='Enter' || event.key===' ') { event.preventDefault(); document.getElementById('pdfUpload').click(); }">
              <div class="flex flex-col items-center pointer-events-none">
                <div class="animate-pulse" aria-hidden="false" role="img" aria-label="PDF upload icon">
                  <svg xmlns="http://www.w3.org/2000/svg" class="w-12 h-12" viewBox="0 0 64 64" focusable="false">
                    <!-- page body -->
                    <rect x="8" y="6" width="48" height="52" rx="6" fill="#ef4444" />
                    <!-- folded corner -->
                    <polygon points="40,6 56,6 40,18" fill="#fca5a5" />
                    <!-- subtle white paper inner -->
                    <rect x="12" y="10" width="36" height="40" rx="3" fill="#fff" opacity="0.06" />
                    <!-- PDF label -->
                    <text x="32" y="38" fill="#fff" font-size="10" font-weight="700" text-anchor="middle"
                      font-family="Arial, Helvetica, sans-serif">PDF</text>
                  </svg>
                </div>
                <div class="mt-2 text-sm text-gray-600">Drop PDF here, or click to browse</div>
                <div class="mt-1 text-xs text-gray-400">Supported: .pdf ‚Ä¢ Multiple files allowed</div>
              </div>

              <!-- Clear file button (top-right of drop area) -->
              <button id="clearFileBtn" type="button"
                class="absolute top-2 right-2 text-xs px-2 py-1 bg-white border rounded-md text-gray-600 hover:bg-gray-50"
                aria-label="Clear uploaded file"
                try { openTabs.slice().forEach(s => { const n=document.getElementById('tab-'+s); if(n) n.remove(); }); openTabs.length=0; activeTab = null; perFileState && Object.keys(perFileState).forEach(k=>{ try{ localStorage.removeItem('rx_pdf_state_'+k); }catch(e){} }); for(const k in perFileState) delete perFileState[k]; const previewContents = document.getElementById('previewContents'); if(previewContents) previewContents.innerHTML=''; const pages = document.getElementById('pagesList'); if(pages) pages.innerHTML=''; const gen = document.getElementById('generatedList'); if(gen) gen.innerHTML=''; document.querySelectorAll('.action-checkbox').forEach(n=>n.checked=false); document.querySelectorAll('.tool-btn').forEach(b=>{ b.classList.remove('bg-red-50','border-red-300'); }); }catch(e){} })();">
                onclick="(function(){ try{ const f = document.getElementById('pdfUpload'); if(f) f.value=''; const filename = window.uploadedFilename || ''; if(filename && typeof uploadUrl !== 'undefined'){ try{ fetch(uploadUrl, { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename }) }).catch(()=>{}); }catch(e){} } window.uploadedFilename=''; window.uploadedFiles = []; if(typeof updateUploadedFilesSelect==='function') updateUploadedFilesSelect(); const explorerList = document.getElementById('uploadedFilesExplorerList'); if(explorerList) explorerList.innerHTML = '<div class=\'text-xs text-gray-400 italic\'>No uploaded files yet.</div>'; const filesCount = document.getElementById('uploadedFilesCount'); if(filesCount) filesCount.innerText = '0'; const sel = document.getElementById('uploadedFilesSelect'); if(sel) sel.innerHTML = '<option value=\'\'>-- Select uploaded file --</option>'; const toggle = document.getElementById('explorerToggle'); if(toggle){ toggle.innerText = '‚àí'; toggle.setAttribute('aria-expanded', 'true'); } // clear preview tabs and per-file state
                try { openTabs.slice().forEach(s => { const n=document.getElementById('tab-'+s); if(n) n.remove(); }); } catch(e) {}
                openTabs.length=0; activeTab = null;
                try { Object.keys(perFileState).forEach(k=>{ try{ localStorage.removeItem('rx_pdf_state_'+k); }catch(e){} delete perFileState[k]; }); } catch(e) {}
                const previewContents = document.getElementById('previewContents'); if(previewContents) previewContents.innerHTML=''; const pages = document.getElementById('pagesList'); if(pages) pages.innerHTML=''; const gen = document.getElementById('generatedList'); if(gen) gen.innerHTML=''; document.querySelectorAll('.action-checkbox').forEach(n=>n.checked=false); document.querySelectorAll('.tool-btn').forEach(b=>{ b.classList.remove('bg-red-50','border-red-300'); }); }catch(e){} })();">
                Clear
              </button>

              <!-- Hidden native file input; clicking the entire area opens it. -->
              <input id="pdfUpload" type="file" accept="application/pdf" class="hidden" multiple />

              <!-- Upload queue / progress (shows file-level progress while uploading).
           Note: we intentionally do not display the "current uploaded filename" here ‚Äî
           uploaded files are visible in the Uploaded Files explorer to the left. -->
              <div id="uploadQueue" class="absolute left-3 right-3 bottom-3 space-y-2 text-left"></div>
            </div>
          </div>
        </div>
      </div>

      <script>
        // Override default file-change behavior with a progress-aware uploader.
        document.addEventListener('DOMContentLoaded', () => {
          const inp = document.getElementById('pdfUpload');
          const queue = document.getElementById('uploadQueue');
          if (!inp || !queue) return;

          inp.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files || []);
            if (!files.length) return;
            for (const f of files) {
              await uploadWithProgress(f);
            }
            // clear native file input after queued uploads
            try { inp.value = ''; } catch (e) { }
          });

          async function uploadWithProgress(file) {
            return new Promise((resolve) => {
              // create UI row
              const row = document.createElement('div');
              row.className = 'bg-gray-900 text-white border border-gray-700 rounded-md p-2 shadow-sm flex flex-col';
              row.innerHTML = `
              <div class="flex items-center justify-between">
                <div class="text-sm font-medium truncate" title="${file.name}">${file.name}</div>
                <div class="text-xs text-gray-300 status">Uploading...</div>
              </div>
              <div class="w-full bg-gray-700 h-2 rounded overflow-hidden mt-2">
                <div class="progress-bar bg-red-600 h-2 w-0" style="width:0%"></div>
              </div>
              `;
              queue.appendChild(row);
              const progressBar = row.querySelector('.progress-bar');
              const status = row.querySelector('.status');

              // use XHR to capture upload progress
              try {
                const xhr = new XMLHttpRequest();
                xhr.open('POST', (typeof uploadUrl !== 'undefined' ? uploadUrl : '/'));
                xhr.upload.onprogress = (ev) => {
                  if (ev.lengthComputable) {
                    const pct = Math.round((ev.loaded / ev.total) * 100);
                    if (progressBar) progressBar.style.width = pct + '%';
                    if (status) status.innerText = pct + '%';
                  }
                };
                xhr.onreadystatechange = () => {
                  if (xhr.readyState === 4) {
                    if (xhr.status >= 200 && xhr.status < 300) {
                      let data = null;
                      try { data = JSON.parse(xhr.responseText); } catch (e) { data = null; }
                      if (data && data.filename) {
                        // mirror existing uploadFile behavior: register uploaded file and load previews
                        const fileObj = { clientName: file.name, size: file.size, serverName: data.filename, total_pages: data.total_pages };
                        window.uploadedFilename = data.filename;
                        window.uploadedFiles = window.uploadedFiles || [];
                        window.uploadedFiles.push(fileObj);
                        if (typeof updateUploadedFilesSelect === 'function') updateUploadedFilesSelect();
                        // do not show filename inside drop area ‚Äî explorer handles that
                        try {
                          if (typeof loadPages === 'function') loadPages(data.total_pages);
                          if (typeof loadThumbnails === 'function') loadThumbnails((typeof uploadsPreviewBase !== 'undefined' ? uploadsPreviewBase : '') + data.filename, data.total_pages);
                        } catch (e) { /* non-fatal */ }
                        if (progressBar) progressBar.style.width = '100%';
                        if (status) status.innerText = 'Done';
                        // small delay then remove row (optional)
                        setTimeout(() => { row.remove(); }, 1600);
                        resolve(data);
                      } else {
                        if (status) status.innerText = 'Failed';
                        row.classList.add('opacity-80');
                        resolve(null);
                      }
                    } else {
                      if (status) status.innerText = 'Error';
                      row.classList.add('opacity-80');
                      resolve(null);
                    }
                  }
                };
                const fd = new FormData();
                fd.append('pdf', file);
                xhr.send(fd);
              } catch (e) {
                if (status) status.innerText = 'Error';
                resolve(null);
              }
            });
          }
        });
      </script>

      <!-- Smart tool area -->
      <!-- Inline toggle-group toolbox: placed under the Smart PDF Toolbox header and above the pages section.
        Keeps same hidden checkboxes and IDs so existing JS logic remains unchanged. -->
  <div id="inlineToolGroupContainer" class="mt-4">
        <div id="inlineToolGroup" role="toolbar" aria-label="PDF Actions"
          class="flex items-center gap-2 flex-nowrap whitespace-nowrap">
          <!-- hidden checkboxes (server logic unchanged) -->
          <input class="sr-only action-checkbox" type="checkbox" value="compress" id="chk-compress" />
          <input class="sr-only action-checkbox" type="checkbox" value="merge" id="chk-merge" />
          <input class="sr-only action-checkbox" type="checkbox" value="split" id="chk-split" />
          <input class="sr-only action-checkbox" type="checkbox" value="remove" id="chk-remove" />
          <input class="sr-only action-checkbox" type="checkbox" value="rotate" id="chk-rotate" />

          <!-- Compress: single inline button with hover/focus popover (no extra column) -->
          <div class="relative" style="display:inline-block;">
            <button id="compressBtn" type="button"
              class="tool-btn inline-flex items-center px-3 py-2 bg-white border rounded-md text-sm shadow-sm"
              data-action="compress" aria-pressed="false" title="Compress" aria-haspopup="true" aria-expanded="false">
              <svg class="w-4 h-4 text-red-600 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                <title>Compress</title>
                <path d="M3 8h6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" />
                <polyline points="7 5 10 8 7 11" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" />
                <path d="M21 16h-6" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" />
                <polyline points="17 19 14 16 17 13" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" />
                <rect x="9.5" y="6.5" width="5" height="3" rx="1" fill="none" stroke="currentColor"
                  stroke-width="1.5" />
                <rect x="9.5" y="14.5" width="5" height="3" rx="1" fill="none" stroke="currentColor"
                  stroke-width="1.5" />
                <path d="M12 9.5v5" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" />
              </svg>

              <span class="label">Compress</span>

              <!-- small current-level badge (updated when selected) -->
              <span id="compressBadge"
                class="ml-2 text-xs text-gray-500 px-1 py-0.5 rounded bg-gray-100 hidden">Balanced</span>

              <!-- caret -->
              <svg class="w-3 h-3 ml-2 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd"
                  d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z"
                  clip-rule="evenodd" />
              </svg>
            </button>

            <!-- Popover: absolute, doesn't affect layout and shows on hover/focus -->
            <div id="compressPopover"
              class="hidden absolute left-0 mt-2 w-44 bg-white border border-gray-200 rounded-md shadow-lg p-2 text-sm z-40"
              role="menu" aria-label="Compression options">
              <div class="mb-2 text-xs text-gray-500">Compression level</div>
              <select id="compressLevelSelect" class="block w-full rounded-md border px-2 py-1 text-sm"
                aria-label="Compression level">
                <option value="default">Balanced</option>
                <option value="fast">Fast (lighter)</option>
                <option value="best">Best (stronger)</option>
                <option value="none">None</option>
              </select>

              <div class="mt-2 flex items-center justify-between">
                <button id="compressApplyBtn" type="button"
                  class="w-full mr-2 inline-flex justify-center items-center px-2 py-1 bg-red-600 text-white rounded text-sm">Apply
                  & Enable</button>
              </div>
            </div>
          </div>

          <script>
            (function () {
              // Improved popover hover/focus handlers for Compress popover.
              const chk = document.getElementById('chk-compress'); // hidden checkbox (keeps server integration)
              const btn = document.getElementById('compressBtn');
              const pop = document.getElementById('compressPopover');
              const sel = document.getElementById('compressLevelSelect');
              const badge = document.getElementById('compressBadge');
              const applyBtn = document.getElementById('compressApplyBtn');

              const labelMap = { default: 'Balanced', fast: 'Fast', best: 'Best', none: 'None' };

              function refreshButtonUI() {
                const level = sel ? sel.value : 'default';
                const pretty = labelMap[level] || level;
                if (chk && chk.checked) {
                  badge.innerText = pretty;
                  badge.classList.remove('hidden');
                  btn.setAttribute('aria-pressed', 'true');
                  btn.classList.add('bg-red-50', 'border-red-300');
                } else {
                  badge.classList.add('hidden');
                  btn.setAttribute('aria-pressed', 'false');
                  btn.classList.remove('bg-red-50', 'border-red-300');
                }
                if (typeof updateCompressInfo === 'function') updateCompressInfo();
              }

              let hideTimer = null;
              function showPopover() {
                if (!pop) return;
                if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
                pop.classList.remove('hidden');
                btn.setAttribute('aria-expanded', 'true');
                adjustPopover();
              }
              function hidePopoverSoon() {
                if (!pop) return;
                if (hideTimer) clearTimeout(hideTimer);
                hideTimer = setTimeout(() => {
                  pop.classList.add('hidden');
                  btn.setAttribute('aria-expanded', 'false');
                }, 220);
              }

              // click toggles selection but should not cause double-toggle by parent handler
              btn.addEventListener('click', (ev) => {
                ev.preventDefault();
                if (chk) {
                  chk.checked = !chk.checked;
                  if (chk.checked) btn.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 260 });
                }
                refreshButtonUI();
                try { if (chk && chk.checked) showPopover(); else hidePopoverSoon(); } catch (e) { }
              });

              // attach both pointer and mouse events for better device support and reliability
              ['pointerenter', 'mouseenter'].forEach(ev => btn.addEventListener(ev, showPopover));
              ['pointerleave', 'mouseleave'].forEach(ev => btn.addEventListener(ev, hidePopoverSoon));
              ['pointerenter', 'mouseenter'].forEach(ev => pop.addEventListener(ev, showPopover));
              ['pointerleave', 'mouseleave'].forEach(ev => pop.addEventListener(ev, hidePopoverSoon));

              // keyboard accessibility
              btn.addEventListener('focus', showPopover);
              btn.addEventListener('blur', hidePopoverSoon);
              pop.addEventListener('focusout', hidePopoverSoon);
              document.addEventListener('keydown', (ev) => {
                if (ev.key === 'Escape') {
                  if (pop) pop.classList.add('hidden');
                  btn.setAttribute('aria-expanded', 'false');
                  btn.focus();
                }
              });

              // apply button: enable compress and close popover
              applyBtn.addEventListener('click', () => {
                if (chk) chk.checked = true;
                refreshButtonUI();
                if (pop) pop.classList.add('hidden');
                btn.setAttribute('aria-expanded', 'false');
                btn.focus();
                if (sel && sel.value === 'best') { try { launchConfetti(); } catch (e) { } }
              });

              if (sel) sel.addEventListener('change', refreshButtonUI);
              refreshButtonUI();
              if (chk) chk.addEventListener('change', refreshButtonUI);

              function adjustPopover() {
                if (!pop) return;
                const rect = pop.getBoundingClientRect();
                if (rect.right > window.innerWidth - 8) { pop.style.right = '0'; pop.style.left = 'auto'; }
                else { pop.style.left = ''; pop.style.right = ''; }
              }
              window.addEventListener('resize', adjustPopover);
              setTimeout(adjustPopover, 50);
            })();
          </script>


          <div class="relative inline-block">
            <button id="mergeBtn" type="button"
              class="tool-btn inline-flex items-center px-3 py-2 bg-white border rounded-md text-sm shadow-sm"
              data-action="merge" aria-pressed="false" title="Merge" aria-haspopup="true" aria-expanded="false">
              <svg class="w-4 h-4 text-red-600 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                <title>Merge</title>
                <path d="M3 6h8" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" />
                <polyline points="8 4 11 6 8 8" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"
                  fill="none" />
                <path d="M21 6h-8" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" />
                <polyline points="16 4 13 6 16 8" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"
                  fill="none" />
                <path d="M12 6v8" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" />
                <polyline points="9.5 15 12 18 14.5 15" stroke-linecap="round" stroke-linejoin="round"
                  stroke-width="1.8" fill="none" />
              </svg>

              <span class="label">Merge</span>

              <span id="mergeBadge"
                class="ml-2 text-xs text-gray-500 px-1 py-0.5 rounded bg-gray-100 hidden">Pages</span>

              <svg class="w-3 h-3 ml-2 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd"
                  d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z"
                  clip-rule="evenodd" />
              </svg>
            </button>

            <div id="mergePopover"
              class="hidden absolute left-0 mt-2 w-48 bg-white border border-gray-200 rounded-md shadow-lg p-3 text-sm z-40"
              role="menu" aria-label="Merge options">
              <div class="mb-2 text-xs text-gray-500">Merge mode</div>

              <select id="mergeModePages" class="block w-full rounded-md border px-2 py-1 text-sm"
                aria-label="Merge Mode">
                <option value="pages">Pages</option>
                <option value="files">Files (Merge Multiple Files)</option>
                <option value="files_pages">Files + Pages</option>
                <option value="none">None</option>
              </select>



              <div class="mt-3">
                <button id="mergeApplyBtn" type="button"
                  class="w-full inline-flex justify-center items-center px-2 py-1 bg-red-600 text-white rounded text-sm">Apply
                  & Enable</button>
              </div>
            </div>
          </div>

          <script>
            (function () {
              // Improved popover hover/focus handlers for Merge popover.
              const chk = document.getElementById('chk-merge');
              const btn = document.getElementById('mergeBtn');
              const pop = document.getElementById('mergePopover');
              const sel = document.getElementById('mergeModePages');
              const badge = document.getElementById('mergeBadge');
              const applyBtn = document.getElementById('mergeApplyBtn');
             
              const labelMap = { default : 'Pages', pages : 'Pages' , files : 'Files', 'files_pages' : 'Files + Pages', none : 'None' };

             
              function refreshButtonUI() {
                const level = sel ? sel.value : 'default';
                const pretty = labelMap[level] || level;
                if (chk && chk.checked) {
                  badge.innerText = pretty;
                  badge.classList.remove('hidden');
                  btn.setAttribute('aria-pressed', 'true');
                  btn.classList.add('bg-red-50', 'border-red-300');
                } else {
                  badge.classList.add('hidden');
                  btn.setAttribute('aria-pressed', 'false');
                  btn.classList.remove('bg-red-50', 'border-red-300');
                }
                if (typeof parsePagesInput == 'function') parsePagesInput();
              }

              let hideTimer = null;
              function showPopover() {
                if (!pop) return;
                if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
                pop.classList.remove('hidden');
                btn.setAttribute('aria-expanded', 'true');
                adjustPopover();
              }
              function hidePopoverSoon() {
                if (!pop) return;
                if (hideTimer) clearTimeout(hideTimer);
                hideTimer = setTimeout(() => {
                  pop.classList.add('hidden');
                  btn.setAttribute('aria-expanded', 'false');
                }, 220);
              }

              btn.addEventListener('click', (ev) => {
                ev.preventDefault();
                if (chk) {
                  chk.checked = !chk.checked;
                  if (chk.checked) btn.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 220 });
                }
                refreshButtonUI();
                try { if (chk && chk.checked) showPopover(); else hidePopoverSoon(); } catch (e) { }
              });

              ['pointerenter', 'mouseenter'].forEach(ev => btn.addEventListener(ev, showPopover));
              ['pointerleave', 'mouseleave'].forEach(ev => btn.addEventListener(ev, hidePopoverSoon));
              ['pointerenter', 'mouseenter'].forEach(ev => pop.addEventListener(ev, showPopover));
              ['pointerleave', 'mouseleave'].forEach(ev => pop.addEventListener(ev, hidePopoverSoon));

              btn.addEventListener('focus', showPopover);
              btn.addEventListener('blur', hidePopoverSoon);
              pop.addEventListener('focusout', hidePopoverSoon);
              document.addEventListener('keydown', (ev) => {
                if (ev.key === 'Escape') {
                  if (pop) pop.classList.add('hidden');
                  btn.setAttribute('aria-expanded', 'false');
                  btn.focus();
                }
              });

              applyBtn.addEventListener('click', () => {
                if (chk) chk.checked = true;
                refreshButtonUI();
                if (pop) pop.classList.add('hidden');
                btn.setAttribute('aria-expanded', 'false');
                btn.focus();
              });

              // wire select change to refresh UI
              if (sel) sel.addEventListener('change', refreshButtonUI);

              refreshButtonUI();
              if (chk) chk.addEventListener('change', refreshButtonUI);

              function adjustPopover() {
                if (!pop) return;
                const rect = pop.getBoundingClientRect();
                if (rect.right > window.innerWidth - 8) { pop.style.right = '0'; pop.style.left = 'auto'; }
                else { pop.style.left = ''; pop.style.right = ''; }
              }
              window.addEventListener('resize', adjustPopover);
              setTimeout(adjustPopover, 50);
            })();
          </script>



          <button type="button"
            class="tool-btn inline-flex items-center px-3 py-2 bg-white border rounded-md text-sm shadow-sm"
            data-action="split" aria-pressed="false" title="Split">
            <svg class="w-4 h-4 text-red-600 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v14"></path>
            </svg>
            Split
          </button>

          <button type="button"
            class="tool-btn inline-flex items-center px-3 py-2 bg-white border rounded-md text-sm shadow-sm"
            data-action="remove" aria-pressed="false" title="Remove pages">
            <svg class="w-4 h-4 text-red-600 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            Remove
          </button>

          <div class="flex items-center space-x-2">
            <button type="button"
              class="tool-btn inline-flex items-center px-3 py-2 bg-white border rounded-md text-sm shadow-sm"
              data-action="rotate" aria-pressed="false" title="Rotate">
              <svg class="w-4 h-4 text-red-600 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v6h6"></path>
              </svg>
              Rotate
            </button>

            <label for="rotateAngle" class="sr-only">Rotate angle</label>
            <select id="rotateAngle" class="rounded-md border text-sm p-1" aria-label="Rotate angle">
              <option value="90">90¬∞</option>
              <option value="180">180¬∞</option>
              <option value="270">270¬∞</option>
            </select>

            <button id="rotateSelectedBtn" type="button"
              class="px-3 py-2 bg-red-100 text-red-700 rounded-md border text-sm">Rotate Selected</button>
          </div>

          <!-- original inline Generate moved to the right column; keep a hidden placeholder so existing JS that
               references `generateBtn` continues to work if needed. -->
          <div class="ml-2">
            <button id="generateBtnPlaceholder" type="button" style="display:none"
              class="px-4 py-2 bg-red-600 text-white rounded-md shadow text-sm">Generate</button>
          </div>
        </div>

        <div class="mt-2 text-xs text-gray-500">Tip: toggle tools to enable actions, select pages from the left column,
          then click Generate.</div>
      </div>

      <script>
        // Make the inline toggle-group keyboard accessible and keep hidden checkboxes in sync.
        (function () {
          const group = document.getElementById('inlineToolGroup');
          if (!group) return;

          group.addEventListener('click', (ev) => {
            // If an inner handler already called preventDefault() (e.g. the
            // individual Compress/Merge button handlers), don't double-toggle
            // the underlying hidden checkbox. This avoids the situation where
            // clicking the button both opens the popover and immediately
            // (incorrectly) toggles the selection.
            if (ev.defaultPrevented) return;

            const btn = ev.target.closest('.tool-btn');
            if (!btn) return;
            const action = btn.getAttribute('data-action');
            if (!action) return;
            const checkbox = Array.from(document.querySelectorAll('.action-checkbox')).find(n => n.value === action);
            if (!checkbox) return;
            checkbox.checked = !checkbox.checked;
            const pressed = checkbox.checked;
            btn.setAttribute('aria-pressed', String(pressed));
            btn.classList.toggle('bg-red-50', pressed);
            btn.classList.toggle('border-red-300', pressed);
            if (typeof updateCompressInfo === 'function') updateCompressInfo();
          });

          // keyboard activation for each button
          group.querySelectorAll('.tool-btn').forEach(b => {
            b.setAttribute('tabindex', '0');
            b.addEventListener('keydown', (ev) => {
              if (ev.key === ' ' || ev.key === 'Enter') { ev.preventDefault(); b.click(); }
            });
          });
        })();
      </script>

      <div class="mt-6 grid grid-cols-1 md:grid-cols-12 gap-6">
        <!-- Left column: Pages list and per-page controls -->
        <section class="md:col-span-3 bg-white rounded-lg p-4 shadow-sm">
          <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold">Files</h3>
            <div class="space-x-2">
              <button id="selectAllBtnFiles"
                class="inline-flex items-center px-2 py-1 text-sm bg-red-600 text-white rounded-md">Select All</button>
              <button id="clearAllBtnFiles"
                class="inline-flex items-center px-2 py-1 text-sm bg-gray-100 rounded-md text-gray-700">Clear</button>
            </div>
          </div>
          <!-- When multiple files are uploaded the user can switch between them -->
          <div class="mb-3">
            <label for="uploadedFilesSelect" class="sr-only">Select uploaded file</label>
            <!-- Explorer-style uploaded files (VS Code-like) -->
            <div id="uploadedFilesExplorer" class="border border-gray-200 rounded-md bg-white p-2">
              <div class="flex items-center justify-between">
                <div class="flex items-center space-x-2">
                  <svg class="w-5 h-5 text-red-600" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7h18M3 12h18M3 17h18" />
                  </svg>
                  <span class="font-medium text-sm">File List</span>
                  <span id="uploadedFilesCount" class="ml-2 text-xs text-gray-500">0</span>
                </div>

                <div class="flex items-center space-x-2">
                  <button id="explorerToggle" type="button" aria-expanded="true"
                    class="text-sm text-gray-500 px-2 py-1 rounded hover:bg-gray-100">‚àí</button>
                </div>
              </div>

              <div id="uploadedFilesExplorerList" class="mt-2 space-y-1 max-h-40 overflow-auto">
                <div class="text-xs text-gray-400 italic">No uploaded files yet.</div>
              </div>

              <div class="mt-2 text-xs text-gray-500">Tip: click "Open" to load a file into the workspace; use the
                checkbox to mark it for batch operations.</div>

              <!-- Hidden legacy select (kept for compatibility). The visible explorer mirrors this. -->
              <select id="uploadedFilesSelect" class="hidden" aria-hidden="true">
                <option value="">-- Select uploaded file --</option>
              </select>
            </div>
          </div>
           <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold">Pages</h3>
            <div class="space-x-2">
              <button id="selectAllBtn"
                class="inline-flex items-center px-2 py-1 text-sm bg-red-600 text-white rounded-md">Select All</button>
              <button id="clearAllBtn"
                class="inline-flex items-center px-2 py-1 text-sm bg-gray-100 rounded-md text-gray-700">Clear</button>
            </div>
          </div>
          <div id="pagesList" class="border border-gray-200 rounded-md p-2 h-64 overflow-auto bg-gray-50"></div>
        </section>

        <!-- Center column: Upload area and Thumbnails preview -->
        <section class="md:col-span-6 bg-white rounded-lg p-4 shadow-sm">
          <div class="flex items-center justify-between mb-3">

            <div class="text-sm text-gray-500">Preview Thumbnails</div>
          </div>
          <!-- Selected file/pages info banner -->
          <!-- Preview tabs: show open previews as browser-style tabs. -->
          <div id="previewTabsWrapper" class="mb-3">
            <div id="previewTabs" class="flex items-center space-x-1 overflow-auto" role="tablist" aria-label="Open previews">
              <!-- tabs inserted here -->
            </div>
            <div id="selectedInfo" class="mt-2 p-3 border rounded-md bg-gray-50 text-sm text-gray-700">
              <div><strong>Selected file:</strong> <span id="selectedFilename">None</span></div>
              <div class="mt-1"><strong>Selected pages:</strong> <span id="selectedPagesInfo">None</span></div>
            </div>
          </div>

           

          <div id="pagePreviewSection">
            <h4 class="text-sm font-medium text-gray-700 mb-2">Page Preview</h4>
            <!-- tabbed preview contents: each open preview gets its own thumbs container -->
            <div id="previewContents" class="rounded-md border border-gray-100 p-2 h-80 overflow-auto bg-white">
              <!-- per-tab thumbs will be added here as children -->
            </div>
          </div>
        </section>

        <!-- Right column: Generated files list and action controls (export, rotate input) -->
        <section class="md:col-span-3 bg-white rounded-lg p-4 shadow-sm">
          <h3 class="font-semibold mb-3">Generated / Actions</h3>
          <div class="mb-3">
            <button id="generateBtn" type="button" class="w-full inline-flex justify-center items-center px-3 py-2 bg-red-600 text-white rounded-md text-sm mb-2">Generate</button>
          </div>
          <ul id="generatedList" class="space-y-2 text-sm"></ul>

          <div id="compressInfo" class="mt-3 text-sm text-gray-600 hidden">
            <div>Original size: <span id="origSize">-</span></div>
            <div>Estimated compressed size: <span id="estSize">-</span></div>
          </div>

          <div class="mt-4 space-y-2">
            <button id="pdfToWordBtn"
              class="w-full inline-flex justify-center items-center px-3 py-2 bg-white border rounded-md text-sm">Export
              Selected ‚Üí Word</button>
            <button id="pdfToExcelBtn"
              class="w-full inline-flex justify-center items-center px-3 py-2 bg-white border rounded-md text-sm">Export
              Selected ‚Üí Excel</button>
          </div>

          <div class="mt-4 text-xs text-gray-500">Rotate by page numbers (e.g. <code>1,3,5-7</code>) or use per-page
            buttons.</div>
          <input id="rotatePagesInput" class="mt-2 block w-full text-sm border rounded-md p-2"
            placeholder="e.g. 1,3,5-7">
        </section>
      </div>


    </div>

    <footer role="contentinfo" class="mt-6 py-6 text-center text-sm text-gray-600">
      &copy; RX Smart Tools
    </footer>
  </main>

  <canvas id="confetti-canvas"></canvas>

  <!-- Scripts: PDF.js (for client-side thumbnails) and application JS logic -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    const uploadUrl = "{{ url_for('pdf.smart_upload') }}";
    const processUrl = "{{ url_for('pdf.smart_process') }}";
    const pdfToWordUrl = "{{ url_for('pdf.pdf_to_word') }}";
    const pdfToExcelUrl = "{{ url_for('pdf.pdf_to_excel') }}";
    const uploadsPreviewBase = "{{ url_for('pdf.serve_upload', filename='') }}";
    const generatedBase = "{{ url_for('pdf.serve_generated', filename='') }}";

    // Global state
    let uploadedFilename = '';
    // per-file in-memory state (also persisted to localStorage)
    // shape: { [serverName]: { selectedPages: [], rotations: {page: angle}, total_pages: n, clientName, size } }
    const perFileState = {};
    let uploadedFiles = []; // { clientName, size, serverName, total_pages }

    // Preview tabs state
    const openTabs = []; // ordered serverName list
    let activeTab = null;

    // utility: debounce
    function debounce(fn, wait) {
      let t = null;
      return function (...args) {
        if (t) clearTimeout(t);
        t = setTimeout(() => { t = null; fn.apply(this, args); }, wait);
      };
    }

    // localStorage helpers
    function storageKeyFor(serverName) { return `rx_pdf_state_${serverName}`; }
    function savePerFileState(serverName) {
      if (!serverName || !perFileState[serverName]) return;
      try { localStorage.setItem(storageKeyFor(serverName), JSON.stringify(perFileState[serverName])); } catch (e) {}
    }
    function loadPerFileState(serverName) {
      if (!serverName) return null;
      try {
        const raw = localStorage.getItem(storageKeyFor(serverName));
        if (raw) return JSON.parse(raw);
      } catch (e) {}
      return null;
    }

    // uploadFile(file): send the PDF file to the server via `uploadUrl`.
    // On success the server should return { filename, total_pages } which
    // we use to populate the pages list and render thumbnails.
    async function uploadFile(file) {
      const fd = new FormData();
      fd.append('pdf', file);
      const res = await fetch(uploadUrl, { method: 'POST', body: fd });
      if (!res.ok) { alert('Upload failed'); return null; }
      const data = await res.json();
      if (data && data.filename) {
        // store the returned filename (server path) and update multi-file state
        const fileObj = { clientName: file.name, size: file.size, serverName: data.filename, total_pages: data.total_pages };
        uploadedFilename = data.filename;
        // update uploaded files registry and UI
        uploadedFiles.push(fileObj);

        // initialize per-file state (load persisted if present)
        const existing = loadPerFileState(data.filename) || { selectedPages: [], rotations: {} };
        perFileState[data.filename] = Object.assign({ total_pages: data.total_pages, clientName: file.name, size: file.size }, existing);
        savePerFileState(data.filename);

        updateUploadedFilesSelect();
        // show last uploaded name in the upload area
        const nameEl = document.getElementById('uploadedName');
        if (nameEl) nameEl.innerText = fileObj.clientName;
        // open preview tab for the newly uploaded file
        openPreviewTab(data.filename);
      } else {
        alert('Upload failed');
      }
    }

    // makePageRow(i): create a DOM row for page `i` containing
    // - a checkbox to select the page
    // - a per-page rotate button (increments rotation by 90¬∞)
    // - a remove button to delete the page locally from the UI
    function makePageRow(i) {
      const div = document.createElement('div');
      div.className = 'flex items-center justify-between p-2 bg-white rounded-md mb-2 border border-gray-100';
      div.innerHTML = `
        <div class="flex items-center">
          <input class="page-checkbox" type="checkbox" value="${i}" id="p${i}" />
          <label for="p${i}" class="ml-2 text-sm">Page ${i}</label>
        </div>
        <div class="flex items-center">
          <button class="rotate-btn text-red-600" data-page="${i}" title="Rotate page by 90¬∞">üîÅ</button>
          <span id="angle-${i}" class="angle-display text-sm ml-2">0¬∞</span>
          <button class="remove-page-btn ml-3 text-sm text-gray-500" data-page="${i}" title="Remove this page">üóëÔ∏è</button>
        </div>
      `;
      return div;
    }

    // loadPages(total): populate the left-side pages list with rows
    // for each page (1..total). Also attaches event handlers for
    // checkbox changes, per-page rotate and per-page remove actions.
    // loadPages(serverName): populate pages list for a specific file (serverName)
    function loadPages(total, serverName) {
      const container = document.getElementById('pagesList');
      container.innerHTML = '';
      if (!serverName) serverName = uploadedFilename;
      if (!serverName) return;
      // ensure per-file state exists
      if (!perFileState[serverName]) perFileState[serverName] = { selectedPages: [], rotations: {}, total_pages: total };
      perFileState[serverName].total_pages = total;

      const selPages = new Set(perFileState[serverName].selectedPages || []);
      const rotations = perFileState[serverName].rotations || {};

      for (let i = 1; i <= total; i++) {
        const row = makePageRow(i);
        // set checkbox state from per-file selections
        const cb = row.querySelector('.page-checkbox');
        if (cb) cb.checked = selPages.has(i);
        // set angle display from per-file rotations
        const angleEl = row.querySelector(`#angle-${i}`) || row.querySelector('.angle-display');
        if (angleEl) angleEl.innerText = (rotations[i] || 0) + '¬∞';
        container.appendChild(row);
      }

      // handlers: when user toggles page checkbox update perFileState and persist
      document.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.addEventListener('change', function () {
          const val = parseInt(this.value, 10);
          const st = perFileState[serverName] || (perFileState[serverName] = { selectedPages: [], rotations: {} });
          if (this.checked) {
            if (!st.selectedPages.includes(val)) st.selectedPages.push(val);
          } else {
            st.selectedPages = st.selectedPages.filter(x => x !== val);
          }
          savePerFileState(serverName);
          try { if (typeof refreshSelectedInfo === 'function') refreshSelectedInfo(); } catch (e) {}
        });
      });

      // wire rotate buttons (update per-file rotations and preview)
      document.querySelectorAll('.rotate-btn').forEach(btn => {
        btn.addEventListener('click', function () {
          const p = parseInt(this.getAttribute('data-page'), 10);
          const st = perFileState[serverName] || (perFileState[serverName] = { selectedPages: [], rotations: {} });
          if (!st.rotations[p]) st.rotations[p] = 0;
          st.rotations[p] = (st.rotations[p] + 90) % 360;
          const angleEl = document.getElementById(`angle-${p}`);
          if (angleEl) angleEl.innerText = st.rotations[p] + '¬∞';
          // update thumbnail preview immediately
          const thumb = document.getElementById(`thumb-${serverName}-p${p}`);
          if (thumb) {
            thumb.style.transform = `rotate(${st.rotations[p]}deg)`;
            thumb.style.transition = 'transform 240ms ease';
          }
          savePerFileState(serverName);
        });
      });

      // per-page remove
      document.querySelectorAll('.remove-page-btn').forEach(btn => {
        btn.addEventListener('click', function () {
          const p = parseInt(this.getAttribute('data-page'), 10);
          // remove row
          const row = this.closest('div');
          if (row) row.remove();
          // remove thumbnail
          const thumb = document.getElementById(`thumb-${serverName}-p${p}`);
          if (thumb) thumb.remove();
          // cleanup selection and rotations
          const st = perFileState[serverName] || (perFileState[serverName] = { selectedPages: [], rotations: {} });
          st.selectedPages = st.selectedPages.filter(x => x !== p);
          delete st.rotations[p];
          savePerFileState(serverName);
          const angleEl = document.getElementById(`angle-${p}`);
          if (angleEl) angleEl.innerText = 'removed';
          try { if (typeof refreshSelectedInfo === 'function') refreshSelectedInfo(); } catch (e) {}
        });
      });

      // refresh banner after pages load
      try { if (typeof refreshSelectedInfo === 'function') refreshSelectedInfo(); } catch (e) {}
    }

    // loadThumbnails(url, total): use PDF.js to render thumbnails for
    // each page from the uploaded PDF URL. Each thumbnail wrapper is
    // given an id `thumb-p{n}` so the UI can rotate or remove it.
    // loadThumbnails(url, total, serverName): render thumbnails into a per-tab container
    async function loadThumbnails(url, total, serverName) {
      if (!serverName) serverName = uploadedFilename;
      if (!serverName) return;
      try {
        // create tab content container if missing
        const previewContents = document.getElementById('previewContents');
        let tabNode = document.getElementById(`tab-${serverName}`);
        if (!tabNode) {
          tabNode = document.createElement('div');
          tabNode.id = `tab-${serverName}`;
          tabNode.className = 'tab-content hidden';
          const thumbs = document.createElement('div');
          thumbs.id = `thumbs-${serverName}`;
          thumbs.className = 'rounded-md grid grid-cols-2 sm:grid-cols-3 gap-3';
          tabNode.appendChild(thumbs);
          previewContents.appendChild(tabNode);
        }

        // cancel previous load if any
        const token = Symbol('load');
        perFileState[serverName].loadToken = token;

        const pdf = await pdfjsLib.getDocument(url).promise;
        // if cancelled, abort
        if (perFileState[serverName].loadToken !== token) return;

        const thumbsEl = document.getElementById(`thumbs-${serverName}`);
        if (!thumbsEl) return;
        thumbsEl.innerHTML = '';

        const seen = new Set();
        for (let i = 1; i <= total; i++) {
          if (seen.has(i)) continue; // safety dedupe
          seen.add(i);
          const page = await pdf.getPage(i);
          // cancel check
          if (perFileState[serverName].loadToken !== token) return;
          const viewport = page.getViewport({ scale: 0.7 });
          const canvas = document.createElement('canvas');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
          const wrapper = document.createElement('div');
          wrapper.className = 'thumb-wrapper bg-gray-50 p-1 rounded-md flex items-center justify-center';
          wrapper.id = `thumb-${serverName}-p${i}`;
          wrapper.dataset.page = i;
          canvas.id = `canvas-${serverName}-p${i}`;
          canvas.style.display = 'block';
          canvas.style.maxWidth = '100%';
          canvas.style.height = 'auto';
          wrapper.style.transition = 'transform 240ms ease';
          wrapper.appendChild(canvas);
          // caption / small label
          const label = document.createElement('div');
          label.className = 'text-xs text-gray-600 mt-1 text-center';
          label.innerText = `Page ${i}`;
          const container = document.createElement('div');
          container.className = 'flex flex-col items-center';
          container.appendChild(wrapper);
          container.appendChild(label);
          thumbsEl.appendChild(container);

          // apply stored rotation if present
          const st = perFileState[serverName] || {};
          if (st.rotations && st.rotations[i]) {
            wrapper.style.transform = `rotate(${st.rotations[i]}deg)`;
          }
        }
      } catch (err) {
        console.warn('thumbnail load failed', err);
      }
    }

    // Tab management
    function updateTabsUI() {
      const tabs = document.getElementById('previewTabs');
      tabs.innerHTML = '';
      openTabs.forEach((srv, idx) => {
        const tbtn = document.createElement('button');
        tbtn.className = 'px-3 py-1 rounded-t-md bg-white border text-sm flex items-center space-x-2';
        tbtn.setAttribute('role', 'tab');
        tbtn.setAttribute('aria-selected', String(activeTab === srv));
        tbtn.tabIndex = 0;
        tbtn.innerHTML = `<span class="truncate max-w-[10rem]">${(perFileState[srv] && perFileState[srv].clientName) || srv}</span>`;
        if (activeTab === srv) tbtn.classList.add('font-semibold');
        tbtn.addEventListener('click', () => switchTab(srv));
        // keyboard: left/right and close via Delete/Escape
        tbtn.addEventListener('keydown', (ev) => {
          if (ev.key === 'ArrowLeft') { const i = openTabs.indexOf(srv); if (i>0) switchTab(openTabs[i-1]); }
          if (ev.key === 'ArrowRight') { const i = openTabs.indexOf(srv); if (i < openTabs.length-1) switchTab(openTabs[i+1]); }
          if (ev.key === 'Delete' || ev.key === 'Escape') { closeTab(srv); }
        });

        // close icon
        const close = document.createElement('button');
        close.className = 'ml-2 p-1 rounded hover:bg-gray-100';
        close.setAttribute('aria-label', `Close ${srv}`);
        close.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>';
        close.addEventListener('click', (ev) => { ev.stopPropagation(); closeTab(srv); });
        tbtn.appendChild(close);
        tabs.appendChild(tbtn);
      });
    }

    function switchTab(serverName) {
      if (!serverName) return;
      activeTab = serverName;
      // show corresponding tab content
      document.querySelectorAll('#previewContents .tab-content').forEach(n => n.classList.add('hidden'));
      const node = document.getElementById(`tab-${serverName}`);
      if (node) node.classList.remove('hidden');
      // update selected filename and pages list to this file
      uploadedFilename = serverName;
      const meta = uploadedFiles.find(x => x.serverName === serverName) || perFileState[serverName] || {};
      const nameEl = document.getElementById('selectedFilename'); if (nameEl) nameEl.innerText = meta.clientName || serverName;
      // load pages into left column using state
      const total = (meta && meta.total_pages) || (perFileState[serverName] && perFileState[serverName].total_pages) || 1;
      loadPages(total, serverName);
      updateTabsUI();
    }

    function openPreviewTab(serverName) {
      if (!serverName) return;
      // if tab already open, focus it
      if (!openTabs.includes(serverName)) openTabs.push(serverName);
      // ensure perFileState initialized
      const meta = uploadedFiles.find(x => x.serverName === serverName) || {};
      if (!perFileState[serverName]) perFileState[serverName] = loadPerFileState(serverName) || { selectedPages: [], rotations: {}, total_pages: meta.total_pages || 1, clientName: meta.clientName, size: meta.size };
      // load thumbnails into its tab
      const total = perFileState[serverName].total_pages || meta.total_pages || 1;
      loadThumbnails((typeof uploadsPreviewBase !== 'undefined' ? uploadsPreviewBase : '') + serverName, total, serverName).then(() => {
        // switch to it when thumbnails ready (deduplicates)
        switchTab(serverName);
      }).catch(() => { switchTab(serverName); });
      updateTabsUI();
    }

    function closeTab(serverName) {
      const idx = openTabs.indexOf(serverName);
      if (idx === -1) return;
      // remove tab entry and DOM content
      openTabs.splice(idx, 1);
      const node = document.getElementById(`tab-${serverName}`);
      if (node) node.remove();
      if (activeTab === serverName) {
        // switch to previous tab or null
        const newActive = openTabs[idx] || openTabs[idx-1] || null;
        if (newActive) switchTab(newActive);
        else {
          activeTab = null;
          // clear pages/thumbs
          document.getElementById('pagesList').innerHTML = '';
          document.querySelectorAll('#previewContents .tab-content').forEach(n => n.classList.add('hidden'));
          const nameEl = document.getElementById('selectedFilename'); if (nameEl) nameEl.innerText = 'None';
        }
      }
      updateTabsUI();
    }

    // file input change: when a user selects a file via the hidden
    // file input we forward it to uploadFile.
    document.getElementById('pdfUpload').addEventListener('change', e => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      // upload sequentially
      (async function () {
        for (const f of files) {
          await uploadFile(f);
        }
      })();
    });

    // Browse button triggers the hidden file input
    const browseBtn = document.getElementById('browseBtn');
    if (browseBtn) {
      browseBtn.addEventListener('click', () => {
        const fileInput = document.getElementById('pdfUpload');
        if (fileInput) fileInput.click();
      });
    }

    // update uploaded files select options
    function updateUploadedFilesSelect() {
      const sel = document.getElementById('uploadedFilesSelect');
      const list = document.getElementById('uploadedFilesExplorerList');
      const count = document.getElementById('uploadedFilesCount');
      if (!sel || !list || !count) return;
      // clear and repopulate select
      sel.innerHTML = '<option value="">-- Select uploaded file --</option>';
      uploadedFiles.forEach(f => {
        const opt = document.createElement('option');
        opt.value = f.serverName;
        opt.text = `${f.clientName} (${Math.round(f.size / 1024)} KB)`;
        sel.appendChild(opt);
      });
      // auto-select the last uploaded file
      if (uploadedFiles.length) sel.value = uploadedFiles[uploadedFiles.length - 1].serverName;

      // render visible explorer list (mirrors the select)
      list.innerHTML = '';
      if (!uploadedFiles.length) {
        list.innerHTML = '<div class="text-xs text-gray-400 italic">No uploaded files yet.</div>';
        count.innerText = '0';
        return;
      }
      uploadedFiles.forEach(f => {
        const wrapper = document.createElement('div');
        wrapper.className = 'flex items-center justify-between p-2 rounded hover:bg-gray-50';
        // compact layout: checkbox adjacent to filename (no separator) and small icon buttons
        wrapper.innerHTML = `
          <div class="flex items-center space-x-2">
            <input class="explorer-file-checkbox file-checkbox" type="checkbox" data-server="${f.serverName}" aria-label="Select ${f.clientName}" />
            <div class="text-sm truncate" style="max-width:160px">${f.clientName}</div>
            <div class="text-xs text-gray-400">${Math.round(f.size/1024)} KB</div>
          </div>
          <div class="flex items-center space-x-1">
            <button class="open-file-icon focus:outline-none p-1 rounded" data-server="${f.serverName}" title="Open preview (tab)" aria-label="Open ${f.clientName} in preview" tabindex="0">
              <!-- open icon -->
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4 4m0 0l-4 4m4-4H3" />
              </svg>
            </button>
            <button class="preview-file-icon focus:outline-none p-1 rounded" data-server="${f.serverName}" title="Open raw file in new tab" aria-label="Preview ${f.clientName} in new window" tabindex="0">
              <!-- preview/new tab icon -->
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h6m0 0v6M13 7L21 15M3 5a2 2 0 012-2h6" />
              </svg>
            </button>
          </div>
        `;
        list.appendChild(wrapper);
      });
      count.innerText = String(uploadedFiles.length);

      // delegate click handlers for open/preview/select
      list.querySelectorAll('.open-file-icon').forEach(b => b.addEventListener('click', (ev) => {
        const server = ev.currentTarget.getAttribute('data-server');
        if (!server) return;
        openPreviewTab(server);
      }));

      list.querySelectorAll('.preview-file-icon').forEach(b => b.addEventListener('click', (ev) => {
        const server = ev.currentTarget.getAttribute('data-server');
        if (!server) return;
        // open the uploaded file preview in a new tab/window
        const url = (typeof uploadsPreviewBase !== 'undefined' ? uploadsPreviewBase : '') + server;
        try { window.open(url, '_blank'); } catch (e) { /* ignore */ }
      }));

      // selection behavior: when selection changes, debounce and auto-open if exactly one is selected
      const debouncedSelectionChanged = debounce(() => {
        const checked = Array.from(list.querySelectorAll('.explorer-file-checkbox:checked')).map(n => n.getAttribute('data-server'));
        // update count/UI if needed
        if (checked.length === 1) {
          openPreviewTab(checked[0]);
        }
        // enable/disable file-level buttons
        const selAllBtn = document.getElementById('selectAllBtnFiles');
        const clearBtn = document.getElementById('clearAllBtnFiles');
        if (selAllBtn) selAllBtn.disabled = uploadedFiles.length === 0;
        if (clearBtn) clearBtn.disabled = uploadedFiles.length === 0;
      }, 180);

      list.querySelectorAll('.explorer-file-checkbox').forEach(cb => cb.addEventListener('change', debouncedSelectionChanged));
      // ensure file-level buttons reflect current state
      const selAllBtn = document.getElementById('selectAllBtnFiles');
      const clearBtn = document.getElementById('clearAllBtnFiles');
      if (selAllBtn) selAllBtn.disabled = uploadedFiles.length === 0;
      if (clearBtn) clearBtn.disabled = uploadedFiles.length === 0;
    }

    // when user selects a different uploaded file from the dropdown
    const uploadedFilesSelect = document.getElementById('uploadedFilesSelect');
    if (uploadedFilesSelect) {
      uploadedFilesSelect.addEventListener('change', function () {
        const val = this.value;
        if (!val) return;
        const found = uploadedFiles.find(x => x.serverName === val);
        if (!found) return;
        uploadedFilename = found.serverName;
        const nameEl = document.getElementById('uploadedName');
        if (nameEl) nameEl.innerText = found.clientName;
        loadPages(found.total_pages);
        loadThumbnails(`${uploadsPreviewBase}${uploadedFilename}`, found.total_pages);
        updateCompressInfo();
      });
    }

    // Drag & drop support: enable dropping files onto the upload area.
    // This sets the same file input files and calls uploadFile so behavior
    // is consistent whether the user clicks or drops.
    const uploadDrop = document.getElementById('uploadDrop');
    uploadDrop.addEventListener('dragover', e => { e.preventDefault(); uploadDrop.classList.add('bg-red-100'); });
    uploadDrop.addEventListener('dragleave', e => { uploadDrop.classList.remove('bg-red-100'); });
    uploadDrop.addEventListener('drop', e => {
      e.preventDefault(); uploadDrop.classList.remove('bg-red-100');
      const files = Array.from(e.dataTransfer.files || []);
      if (!files.length) return;
      // mirror into the hidden input.files for compatibility, then upload sequentially
      try {
        document.getElementById('pdfUpload').files = e.dataTransfer.files;
      } catch (e) {
        // setting files may throw in some browsers; it's non-essential
      }
      (async function () {
        for (const f of files) {
          await uploadFile(f);
        }
      })();
    });

    // Select / Clear actions for the pages list
    document.getElementById('selectAllBtn').addEventListener('click', () => {
      document.querySelectorAll('.page-checkbox').forEach(cb => { cb.checked = true; cb.dispatchEvent(new Event('change')); });
    });


    document.getElementById('clearAllBtn').addEventListener('click', () => {
      document.querySelectorAll('.page-checkbox').forEach(cb => { cb.checked = false; cb.dispatchEvent(new Event('change')); });
    });

    // Select / Clear actions for the Files list
    document.getElementById('selectAllBtnFiles').addEventListener('click', () => {
      document.querySelectorAll('.file-checkbox').forEach(cb => { cb.checked = true; cb.dispatchEvent(new Event('change')); });
    });


    document.getElementById('clearAllBtnFiles').addEventListener('click', () => {
      document.querySelectorAll('.file-checkbox').forEach(cb => { cb.checked = false; cb.dispatchEvent(new Event('change')); });
    });

    // getCheckedActions(): returns an array of enabled global actions
    // from the sticky actions bar (compress/merge/split/remove/rotate)
    function getCheckedActions() {
      const actions = [];
      // still read from hidden checkboxes (keeps server integration unchanged)
      document.querySelectorAll('.action-checkbox:checked').forEach(node => actions.push(node.value));
      return actions;
    }


    function updateCompressInfo() {
      // Compression ratio UI removed ‚Äî keep hidden to avoid UI clutter.
      const info = document.getElementById('compressInfo');
      if (info) info.classList.add('hidden');
    }

    // parsePagesInput(str): helper to parse page range strings like
    // "1,3,5-7" into an array of page numbers [1,3,5,6,7]. Used for
    // rotate input and other range-entry features.
    function parsePagesInput(str) {
      if (!str) return [];
      const out = new Set();
      str.split(',').map(s => s.trim()).forEach(part => {
        if (!part) return;
        if (part.includes('-')) {
          const [a, b] = part.split('-').map(x => parseInt(x, 10));
          if (!Number.isNaN(a) && !Number.isNaN(b)) {
            for (let i = Math.min(a, b); i <= Math.max(a, b); i++) out.add(i);
          }
        } else {
          const n = parseInt(part, 10);
          if (!Number.isNaN(n)) out.add(n);
        }
      });
      return Array.from(out).sort((a, b) => a - b);
    }

    // refreshSelectedInfo(): update the small banner above previews
    function refreshSelectedInfo() {
      const fnameEl = document.getElementById('selectedFilename');
      const pagesEl = document.getElementById('selectedPagesInfo');
      try {
        const meta = (uploadedFiles || []).find(x => x.serverName === uploadedFilename) || {};
        if (fnameEl) fnameEl.innerText = meta.clientName || (uploadedFilename || 'None');
        const st = perFileState[uploadedFilename] || { selectedPages: [] };
        if (pagesEl) pagesEl.innerText = (st.selectedPages && st.selectedPages.length) ? st.selectedPages.join(',') : 'None';
      } catch (e) { /* ignore */ }
    }

    // explorer toggle collapse
    const explorerToggleBtn = document.getElementById('explorerToggle');
    if (explorerToggleBtn) {
      explorerToggleBtn.addEventListener('click', () => {
        const list = document.getElementById('uploadedFilesExplorerList');
        if (!list) return;
        const hidden = list.classList.toggle('hidden');
        explorerToggleBtn.innerText = hidden ? '+' : '‚àí';
        explorerToggleBtn.setAttribute('aria-expanded', String(!hidden));
      });
    }

    // showGeneratedFiles(listNames): render links for output files
    // produced by server side processing (preview/download links).
    function showGeneratedFiles(listNames) {
      const list = document.getElementById('generatedList');
      list.innerHTML = '';
      const seen = new Set();
      (listNames || []).forEach(name => {
        if (!name || seen.has(name)) return;
        seen.add(name);
        const li = document.createElement('div');
        li.className = 'flex items-center justify-between p-2 border rounded-md bg-white';
        li.innerHTML = `<span class="truncate max-w-xs">${name}</span>
          <div class="space-x-2">
            <a href='${generatedBase}${name}' target='_blank' class='text-red-600 text-sm'>Preview</a>
            <a href='${generatedBase}${name}' class='text-green-600 text-sm' download>Download</a>
          </div>`;
        list.appendChild(li);
      });
    }

    // applyRotationToPreview(page, angle): helper to visually rotate
    // the thumbnail wrapper for `page` by `angle` degrees. This is a
    // client-side-only preview; server must apply rotations to the PDF
    // when generating final outputs.
    function applyRotationToPreview(page, angle) {
      const server = activeTab || uploadedFilename;
      if (!server) return;
      const wrapper = document.getElementById(`thumb-${server}-p${page}`) || document.getElementById(`thumb-p${page}`);
      if (!wrapper) return;
      wrapper.style.transform = `rotate(${angle}deg)`;
      wrapper.style.transition = 'transform 240ms ease';
    }

    // Rotate selected pages button handler: applies angle to each
    // selected page in the UI and updates the per-page rotation state.
    document.getElementById('rotateSelectedBtn').addEventListener('click', () => {
      if (!uploadedFilename) { alert('Please upload a PDF first'); return; }
      const st = perFileState[uploadedFilename] || { selectedPages: [], rotations: {} };
      const angle = parseInt(document.getElementById('rotateAngle').value || '90', 10);
      if (!st.selectedPages || st.selectedPages.length === 0) { alert('Select pages to rotate'); return; }
      st.selectedPages.forEach(p => {
        if (!st.rotations[p]) st.rotations[p] = 0;
        st.rotations[p] = (st.rotations[p] + angle) % 360;
        const angleEl = document.getElementById(`angle-${p}`);
        if (angleEl) angleEl.innerText = st.rotations[p] + '¬∞';
        applyRotationToPreview(p, st.rotations[p]);
      });
      savePerFileState(uploadedFilename);
    });

    // launchConfetti(): small celebratory effect used when outputs are generated
    function launchConfetti() {
      const canvas = document.getElementById('confetti-canvas');
      const ctx = canvas.getContext('2d');
      function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
      resize(); window.addEventListener('resize', resize);

      const colors = ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
      const particles = [];
      const count = 80;
      for (let i = 0; i < count; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * -canvas.height * 0.5,
          vx: (Math.random() - 0.5) * 6,
          vy: Math.random() * 6 + 2,
          size: Math.random() * 8 + 4,
          color: colors[Math.floor(Math.random() * colors.length)],
          rot: Math.random() * Math.PI
        });
      }

      let t0 = performance.now();
      function frame(now) {
        const dt = (now - t0) / 1000; t0 = now;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.12; // gravity
          p.rot += 0.1;
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
          ctx.restore();
        });
        // stop and clear after ~2.6s
        if (now - t0 > 2600) {
          // nothing; continue until timeout below
        }
        requestAnimationFrame(frame);
      }

      // run for ~2.5s then clear
      requestAnimationFrame(frame);
      setTimeout(() => { ctx.clearRect(0, 0, canvas.width, canvas.height); }, 2600);
    }

    // Generate button: collect enabled actions, selected pages and
    // rotations, then POST to `processUrl` for server-side processing.
    // The server response should include a `generated` array with
    // produced filenames which are shown in the UI.
    document.getElementById('generateBtn').addEventListener('click', async () => {
      const actions = getCheckedActions();
      const explorerSelected = Array.from(document.querySelectorAll('.explorer-file-checkbox:checked')).map(n => n.getAttribute('data-server'));
      if (!uploadedFilename && explorerSelected.length === 0) { alert('Please upload a PDF first or select files from the Uploaded Files explorer'); return; }
      if (actions.length === 0) { alert('Select at least one action'); return; }

      // current per-file selection/rotations
      const currentState = uploadedFilename ? (perFileState[uploadedFilename] || { selectedPages: [], rotations: {} }) : { selectedPages: [], rotations: {} };

      // parse rotate range input and merge into rotations if provided
      const rotatePagesInput = document.getElementById('rotatePagesInput').value;
      const rotatePagesParsed = parsePagesInput(rotatePagesInput);
      const rotations = Object.assign({}, currentState.rotations || {});
      if (rotatePagesParsed && rotatePagesParsed.length > 0) {
        const globalAngle = parseInt(document.getElementById('rotateAngle').value || '90', 10);
        rotatePagesParsed.forEach(page => {
          const cur = rotations[String(page)] || 0;
          rotations[String(page)] = (cur + globalAngle) % 360;
        });
      }

      // build payload: include actions, selected pages, rotations
      const pagesForPrimary = Array.isArray(currentState.selectedPages) ? currentState.selectedPages.slice() : [];
      const payload = { actions: actions, pages: pagesForPrimary, rotations: rotations };
      const compressSelected = actions.includes('compress');
      const compressLevel = (document.getElementById('compressLevelSelect') && document.getElementById('compressLevelSelect').value) || 'default';

      // Determine filenames list (support explorer multi-select or single uploaded file)
      const selectedFiles = (explorerSelected && explorerSelected.length) ? explorerSelected.slice() : (uploadedFilename ? [uploadedFilename] : []);

      // always include filenames for batch operations (merge/files/compress)
      if (selectedFiles.length > 0) payload.filenames = selectedFiles;
      else if (uploadedFilename) payload.filename = uploadedFilename; // legacy single-file

      if (compressSelected) payload.compression_level = compressLevel;

      // Include merge_mode and file_page_map when merge is enabled
      const mergeSelect = document.getElementById('mergeModePages');
      const mergeValue = mergeSelect ? mergeSelect.value : 'pages';
      // normalize to server merge_mode values
      let merge_mode = 'none';
      if (mergeValue === 'pages') merge_mode = 'pages_per_file';
      else if (mergeValue === 'files') merge_mode = 'files_whole';
      else if (mergeValue === 'files_pages') merge_mode = 'files_and_pages';
      payload.merge_mode = merge_mode;

      // For modes that need per-file page maps, build a map of serverName -> pages using perFileState when available
      if (merge_mode === 'pages_per_file' || merge_mode === 'files_and_pages') {
        const filePageMap = {};
        const targets = (payload.filenames && payload.filenames.length) ? payload.filenames : (payload.filename ? [payload.filename] : []);
        targets.forEach(fn => {
          const st = perFileState[fn] || { selectedPages: [] };
          filePageMap[fn] = Array.isArray(st.selectedPages) ? st.selectedPages.slice() : [];
        });
        payload.file_page_map = filePageMap;
      }

      try {
        const resp = await fetch(processUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const data = await resp.json();
        showGeneratedFiles(data.generated || []);
        // surprise: if generated files were produced, launch confetti
        if (data.generated && data.generated.length > 0) { try { launchConfetti(); } catch (e) { /* non-fatal */ } }
      } catch (err) { console.warn('Generate failed', err); alert('Generation failed'); }
    });

    // Export to Word: send selected pages to server to convert to Word
    document.getElementById('pdfToWordBtn').addEventListener('click', async () => {
      if (!uploadedFilename) { alert('Upload a PDF first'); return; }
      const st = perFileState[uploadedFilename] || { selectedPages: [] };
      if (!st.selectedPages || st.selectedPages.length === 0) { alert('Select pages to export'); return; }
      const resp = await fetch(pdfToWordUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: uploadedFilename, pages: st.selectedPages }) });
      const data = await resp.json();
      if (data.generated && data.generated.length) { showGeneratedFiles((data.generated || [])); try { launchConfetti(); } catch (e) { } } else { alert('Conversion failed'); }
    });

    // Export to Excel: send selected pages to server to convert to Excel
    document.getElementById('pdfToExcelBtn').addEventListener('click', async () => {
      if (!uploadedFilename) { alert('Upload a PDF first'); return; }
      const st = perFileState[uploadedFilename] || { selectedPages: [] };
      if (!st.selectedPages || st.selectedPages.length === 0) { alert('Select pages to export'); return; }
      const resp = await fetch(pdfToExcelUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: uploadedFilename, pages: st.selectedPages }) });
      const data = await resp.json();
      if (data.generated && data.generated.length) { showGeneratedFiles((data.generated || [])); try { launchConfetti(); } catch (e) { } } else { alert('Conversion failed'); }
    });
  </script>
</body>

</html>